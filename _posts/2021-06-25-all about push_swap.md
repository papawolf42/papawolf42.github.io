---
title: All About push_swap
tags: [All About, 42Seoul, push_swap, quick sort]
---

# push_swap

## simulator

- ~~공백 더 출력되는 거 고쳐야함~~
- ~~출력 갱신만 구현하고 커밋한번.~~
- ~~아래 스택표시도 만들어야할듯~~
- ~~갯수 새주는 것도 추가하면 좋을 듯.~~

## plan

- 3개와 5개인가? 평가표에 나와있는 것으로 연습을 해본다.
- **알고리즘을 내가 자체적으로 파악하는게 우선**
- 재귀를 2번 부르는 것을 한번 검토해본다. 그런데 이건 시간초과로 발산할 가능성이 매우 높음.
- (checker) gnl을 사용해야함.
- (완성) 3개짜리 배열
  - 이제 9개짜리가 들어오면, 피봇 2개를 정해서, 재귀 없이 퀵소트만으로 정렬해보자.



## 임의의 수 3개가 들어올 경우

- 3개의 수는 크기는 관계 없으니 `1, 2, 3`으로 잡는다

- 3개의 수를 배열하는 방법의 경우의 수는 총 몇가지가 있을까? 3 factorial이므로 **6개**!

- 그런데 경우의 수 하나는 오름차순으로 정렬 되어 있으므로 제외

  - `1 2 3` X
  - `1 3 2: sa ra`
  - `2 1 3: sa`
  - `2 3 1: rra`
  - `3 1 2: ra`
  - `3 2 1: sa rra`

- 각 수를 최소한의 경우의 명령수를 생각해보자.

  ```shell
  ➜  02_push_swap git:(main) ✗ ./simulator 1 3 2
  --------------------------------------------------------------------------------
  Init a and b
  1 
  3 
  2 
  - -
  a b
  --------------------------------------------------------------------------------
  Exec sa [1]:
  3 
  1 
  2 
  - -
  a b
  --------------------------------------------------------------------------------
  Exec ra [2]:
  1 
  2 
  3 
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  ```shell
     ➜  02_push_swap git:(main) ✗ ./simulator 2 1 3
     --------------------------------------------------------------------------------
     Init a and b
     2 
     1 
     3 
     - -
     a b
     --------------------------------------------------------------------------------
     Exec sa [1]:
     1 
     2 
     3 
     - -
     a b
     --------------------------------------------------------------------------------
  ```

  ```shell
  ➜  02_push_swap git:(main) ✗ ./simulator 2 3 1
  --------------------------------------------------------------------------------
  Init a and b
  2 
  3 
  1 
  - -
  a b
  --------------------------------------------------------------------------------
  Exec rra [1]:
  1 
  2 
  3 
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  ```shell
  ➜  02_push_swap git:(main) ✗ ./simulator 3 1 2
  --------------------------------------------------------------------------------
  Init a and b
  3 
  1 
  2 
  - -
  a b
  --------------------------------------------------------------------------------
  Exec ra [1]:
  1 
  2 
  3 
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  ```shell
  ➜  02_push_swap git:(main) ✗ ./simulator 3 2 1
  --------------------------------------------------------------------------------
  Init a and b
  3 
  2 
  1 
  - -
  a b
  --------------------------------------------------------------------------------
  Exec sa [1]:
  2 
  3 
  1 
  - -
  a b
  --------------------------------------------------------------------------------
  Exec rra [2]:
  1 
  2 
  3 
  - -
  a b
  --------------------------------------------------------------------------------
  ```

- 1번 내지는 2번의 명령으로 모두 정렬.

- `1 3 2` 의 경우 3번이 필요할 줄 알았는데, 2번만에 됨. 직접 해보길 바람.

### stack b 에서의 규칙

- 정렬은 같아도, 규칙이 정 반대니 생각해보자.

  - `1 2 3: sb rrb` 
  - `1 3 2: rb`
  - `2 1 3: rrb`
  - `2 3 1: sb`
  - `3 1 2: sb rb`
  - `3 2 1` X

- 시뮬레이터

  ```shell
  --------------------------------------------------------------------------------
  Exec sb [4]:
    2
    1
    3
  - -
  a b
  --------------------------------------------------------------------------------
  Exec rrb [5]:
    3
    2
    1
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  ```shell
  --------------------------------------------------------------------------------
  Exec pb pb pb [3]:
    1
    3
    2
  - -
  a b
  --------------------------------------------------------------------------------
  Exec rb [4]:
    3
    2
    1
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  ```shell
  --------------------------------------------------------------------------------
  Exec pb pb pb [3]:
    2
    1
    3
  - -
  a b
  --------------------------------------------------------------------------------
  Exec rrb [4]:
    3
    2
    1
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  ```shell
  --------------------------------------------------------------------------------
  Exec pb pb pb [3]:
    2
    3
    1
  - -
  a b
  --------------------------------------------------------------------------------
  Exec sb [4]:
    3
    2
    1
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  ```shell
  --------------------------------------------------------------------------------
  Exec pb pb pb [3]:
    3
    1
    2
  - -
  a b
  --------------------------------------------------------------------------------
  Exec sb [4]:
    1
    3
    2
  - -
  a b
  --------------------------------------------------------------------------------
  Exec rb [5]:
    3
    2
    1
  - -
  a b
  --------------------------------------------------------------------------------
  ```

  

  

## 임의의 수 5개가 들어올 경우

- 이 경우 경우의 수는 5!, 120개인데, 한경우를 제외하면 119개.
- pb를 2번 하면, 임의의 수 3개의 문제가 된다. 
- 2[pb*2] + 2[a 정렬] + 2[최대 2번의 ra] + 2[pa] + 4[최대 4번의 ra], 즉 최대 12번의 명령어 문제가 된다.

### jhp 최악

```shell
--------------------------------------------------------------------------------
Init a and b
3
1
5
4
2
- -
a b
--------------------------------------------------------------------------------
Exec ra [1]:
1
5
4
2
3
- -
a b
--------------------------------------------------------------------------------
Exec pb [2]:
5
4
2
3 1
- -
a b
--------------------------------------------------------------------------------
Exec ra [3]:
4
2
3
5 1
- -
a b
--------------------------------------------------------------------------------
Exec ra [4]:
2
3
5
4 1
- -
a b
--------------------------------------------------------------------------------
Exec pb [5]:
3
5 2
4 1
- -
a b
--------------------------------------------------------------------------------
Exec sa [6]:
5
3 2
4 1
- -
a b
--------------------------------------------------------------------------------
Exec ra [7]:
3
4 2
5 1
- -
a b
--------------------------------------------------------------------------------
Exec pa pa [9]:
1
2
3
4
5
- -
a b
--------------------------------------------------------------------------------
```



- 1번 head를 기준으로 2(+1)번 neck과 7(-1)번 tail이 small이고, 
  4(+3)번과 5(-3)번이 small인 경우.

- 동시에 최악은 big과 a가 sa와 sb를 많이써야하게 뒤죽박죽일 경우이다. 한번 만들어보자.

  ```shell
  --------------------------------------------------------------------------------
  Init a and b
  7
  1
  6
  4
  3
  5
  2
  - -
  a b
  ```

- 7개 짜리를 재귀로 돌릴 수 있나?

  - ra를 할지와 rra를 할지 선택에서 분기 2개

- 1, 2, 3, 4가 들어오는 경우를 생각해보자.

  - 끝자리 수가 들어오지 않는다면 1, 2, 3 이나 2, 3, 4 로 정렬이 가능할 것이다.
  - 그럼 이 전에는 2가지 경우가 존재 1, 2 처럼 연속된 수가 먼저 정렬되거나, 1, 3 처럼 비연속된 경우이다.
    - 1, 2처럼 연속된 경우는 3을 넣어주면 즉시 정렬
    - 2, 1의 경우 sb를 사용한 뒤, 3을 넣어주면 1, 2, 3이 된다
    - 1, 3의 경우 2가 들어오면 sb를 사용하면 1, 2, 3이되고
    - 3, 1의 경우 2가 들어오면 rrb를 사용하면 1, 2, 3이 된다.
    - 즉, 1, 2, 3이나 2, 3, 4 처럼 연속된 경우에는 한개의 명령어로 쉽게 정렬됨
      - 1, 2, 3 에서 4가 들어온다면 즉시 정렬이고
      - 2, 3, 4에서 1이 들어온다면 rb를 하면 정렬된다.
  - 이제 1, 2, 4나 1, 3, 4 와 같이 비 연속된 경우를 생각해 보자.
    - 이건 역순으로 1, 2, 4에서 3이 들어오는 경우를 생각해보자
      - [1] sb: 1, 2, 3, 4가 된다.
    - 1, 3, 4에서 2가 들어오는 경우를 생각해보자.
      - [2] 3, 4, 1 상태로 대기한 다음, 2를 넣어준 다음, rb rb 해주는 게 베스트.
      - 그러기 전에 준비를 해야지 그럼 다시 3가지로 분류됨
        - 3, 4인 상황 - 1이 들어오면 대기하다가 2받고 rb rb
        - 3, 1인 상황 - 4가 들어오니까 
        - 4, 1인 상황

- 이건 재귀가 맞는 이유가, 두개의 스택을 동시에 생각해야 된다는 점이다. 

  - 줄일 수 있는 명령어가 있어서 줄이고 싶다면, 미리 명령어를 파악해야함.
  - 그럼데 미리 파악하는게 재귀가 아니고서야 고려해야할 변수가 너무 많음.
  - 경우의 수가 수십개가 된다는 이야기

- 가장 먼저 정렬성을 살펴보는게 중요하다. 그리고 ra 내지는 rra를 쓰고 시작하는지를 선택해야함.

- ra와 rra를 쓰는 것을 분기.

- 정렬성을 따지는데 big과 small의 정렬성 모두를 조사함. 

- 456 4321 이런식이면 가장 좋겠지만, 그 역순도 언제든지 가능. 그럼 sb가 사용될 것이고, sa도 사용된다면 ss를 사용하는게 좋음. 마찬가지 이유로 ra와 rb를 고려해 rr을 사용하는게 좋음. 근데 이를 어떻게 의존성을 따질것인가? 



- 그러면 일단은 3개를 마감으로 하고 재귀를 짜보자. 일단은!!



## 임의의 수 10개를 수작업으로 풀어보며

```shell
--------------------------------------------------------------------------------
Init a and b
 9 
 2 
 3 
 8 
 5 
 7 
 6 
10 
 1 
 4 
-- --
 a  b

1, 2, ... 8, 9, 10 이므로 총 10개.
2개의 피봇을 정해야 하니까.
1 ~ 10 에서 3구간으로 나눠야함 그러면 가장 큰 수를 나누기 3 한뒤 1과 2를 곱하면 됨
pivot 1 : 3 = 10 / 3 * 1
pivot 2 : 6 = 10 / 3 * 2

3과 6이 결정되었으니, 이상, 초과, 이하, 미만을 결정해야되는데
1 ~ 3, 4 ~ 6, 7 ~ 10 로 3 3 4으로 나누는게 일단은 좋을 것 같으니,
구간 1: 3 이하
구간 2: 3 초과 6 이하
구간 3: 6 초과
이렇게 하면 될듯

이 경우를 구간이 3으로 줄었을때를 생각해보자
1 2 3 이렇게 남았다
pivot 1 : 1 = 3 / 3 * 1
pivot 2 : 2 = 3 / 3 * 2
구간 1: 1 이하
구간 2: 1 초과 2 이하
구간 3: 2 초과

	생각 1) 최적화는 나중에 하고, 일단은 작동하는 피봇 2개의 퀵소트를 적용하는 것이 우선이라는 생각이 든다.

	고민 1) stack a를 정렬하면서 바로바로 고정a 부분을 정렬하면서 넣을지, pb 과정이 종료된 후에 따로 정렬을 할지 고민

	문제 1) 고정b 부분을 bottom 쪽에서 정렬을 하려다 보니까, sb가 필요한 경우를 위해 2구간을 bottom에 고정시킨 상태로, 구간 3을 stack b의 top쪽에서 정렬을 한 다음, rb로 위치를 전환해주는 쪽이 더 나을 수도.
	문제 2) 위에거는 틀렸음. minckim님 가이드의 4.2를 보면 그 고찰이 녹아든 그림이 나옴. 구간 2는 들어오자마자 rb를 통해 stack b의 bottom으로 내려버림. 그리고 구간 3을 stack b의 top에서 정렬을 시킴(내림차순으로). 그리고 완료되면 rrb를 통해, 구간 2를 stack b의 top으로 올림.
	
	설계 1) sa sb를 ss로, ra rb를 rr로, rra rrb를 rrr로 줄이려면, 연결리스트의 복사본을 만들던가해서, 정렬을 미리 진행해보고, 최소한의 명령셋을 배열로 만든 다음, 공동으로 사용하는 pair 구간을 나눠서 진행해야한다. 이 작업은 스택 3개를 정렬하므로, 유연하게 적용되어야 한다.
	
	설계 2) pb로 넘기다가, ra와 rb를 동시에 써야하는 순간, 즉 구간 2를 stack b 아래로 내리면서 구간 3을 stack a 아래로 내려야 하는 상황에 rr을 써서 명령 하나를 줄일 수 있다. 
	
	설계 3) a_to_b에서는 구간 1과 구간 2가 각 스택의 고정 부 아래에 위치하게 된다. 이렇게 넣어줄때도 정렬을 하면서 넣어줄 수 있을까? 바로 바로 넣는게 아니라, 정렬을 하면서 넣어주려면, 그러기 위해선 역시 pb로 넘겨주면서 a 스택의 top 아래쪽에 상황을 적절히 보아야 한다. 구간 2를 stack b 아래쪽으로 내리는데 stack a top 아래쪽에 구간 2가 위치한다면 적절히 정렬해줄 수 있지만. 그 사이에 구간 1이 위치한다면 어쩔 수 없이 rb로 넘겨줘야 하리라.
	
	설계 4)

--------------------------------------------------------------------------------
Exec pb [14]:
    4
    6
 8  5
 9  3
 7  2
10  1
-- --
 a  b
 
 이 부분 해석
 구간 3은 7 8 9 10 이 되어야 하는데 8 9 7 10이 되어있음. 이를 정렬하는 방법을 고민해야함. 지금 당장은 4개지만, 만약에 100개가 들어온다면 저 부분이 33개짜리임.
 5개라면 12개의 최대 12개의 명령어. 



## 의사코드

​``` C
if (종료조건: 3개든 5개든 최소범위라면)
{
	"3개든 5개든 최소범위에서 최적 정렬을 진행, 3개라면 2번, 5개라면 12번" 여기서 5개를 정렬할 최적화를 만들것인가 혹은 기존의 재귀를 그대로 돌려서 범위를 3이하로 줄일것인가는 두개 모두 구현하여 명령어수 차이를 비교해보자.
	return ;
}
(실행부분)
	"ft_ 피봇을 적절하게 정한다 2개를" 
	"ft_ 3개의 범위를 정한다. 이때 모든 수를 포함하는데, large midium small로 나눈다." 이때, 각 범위의 stack의 위치를 적어주어야한다.
  "ft_ push_two_thrid"
  "ft_ recursive(large)"
  "ft_ recursive(midium)"
  "ft_ recursive(small)"
  "ft_ push_back"
```



```C
ARG="2 4 19 12 28 30 7 27 16 1 11 23 13 22 18 5 14 21 3 24 29 17 10 9 6 15 8 25 20 26"
    

/*
pb pb pb rb pb 
rb ra ra pb ra 
pb rb pb pb ra 
pb rb ra pb rb 

아마도, 1 ~ 10, 11 ~ 20, 21 ~ 30으로 잡힌 듯 하다.
아니네 11 ~ 21이네...

21 pb pb rb pb rb 
26 pb ra ra pb rb 
31 pb pb pb pb rb 
36 pb ra pb rb ra 

여기까지 하면, 
--------------------------------------------------------------------------------
Exec ra [40]:
    8 < small top
    6
    9
   10
    3
    5
   11
    1
    7
    4
    2 < small bottom
			< [b쪽 가상의 고정부]
   19 < mid top
   <<<< [a쪽 가상의 고정부]
28 12
30 16
27 13
23 18
22 14
24 21
29 17
25 15
26 20 < mid bottom
-- --
 a  b
--------------------------------------------------------------------------------
이렇게 남는다
a        : 22 ~ 30
b bottom : 12 ~ 21
b top    : 1  ~ 11
피봇을 어떻게 구하는지 알 수 없지만, 30개인데 11이하, 21이하 가 기준이 된다. 
10이하, 20이하면 더 좋을 것 같기도

rrr rrr rrr rrr rrr 
rrr rrr rrr rrr rrb 

근데 항상 rrr의 마지막을 rrb로 하나?(이건 고정부 떄문, 뒤에가면 더 이해하기 쉬움)
--------------------------------------------------------------------------------
Exec rrb [50]:
   19
   12
   16
   13
   18
   14
   21
   17
   15
   20 <- 이 위로 mid range
    8 <- 이 아래로 small range
    6
28  9
30 10
27  3
23  5
22 11
24  1
29  7
25  4
26  2
[a] [b] << 양쪽 고정부가 여기로 이동함.
-- --
 a  b
--------------------------------------------------------------------------------

여기서 다시금 a 스택에서 3분할을 한다. 아마도 총합에대해서 1/3과 2/3으로 만든 뒤, 인덱스에 +1을 기준으로 잡는듯
(22 + 23 + ... + 29 + 30) = 234
여기서 중간값을 계산하려면, 경국 최소인덱스에 21을 빼주고 최고인덱스 값을 취한다.
혹은 max - min + 1로 해도 될듯
30(max) - 22(min) + 1 = 9
left pivot  : 3 = 9 / 3 * 1
right pivot : 6 = 9 / 3 * 2
그런 다음 min값에 더해주면?
left pivot  : 25 = 22 + 3
right pivot : 28 = 25 + 3
이하로 쳐버리면
22 ~ 25
26 ~ 28
29 ~ 30
미만을 적용하면
22 ~ 24 (3)
25 ~ 27 (3)
28 ~ 30 (3)
음 어렵구만... 나머지가 어떻게 적용될지 모름
각각 (h)eavy (m)id (l)ight 혹은 (b)ig (m)id (s)mall 이라고 하자. bms가 더 이쁘다.

28 b
30 b
27 m
23 s
22 s
24 s
29 b
25 m
26 m
--
 a
 
27


m'(2, 3)
b'(1, 9) << standard
b'(2, 3)
---
a

s(1, 9)
s'(2, 3)
___
b

pb rb ra pb rb 
pb pb pb ra pb 
pb rb rrr rrr rrb 

구간이 생각과 다르게 초반에 정한
22 ~ 25 s
26 ~ 28 m
29 ~ 30 b
이렇게 정해졌었다.
자 이제 a_to_b의 종료조건에 도달함. 
아마도 종료조건이 stack에 3개이하일거라 생각됨. 
여기에 재량에 따라 이 stack의 크기는 늘어날 수 있을 걸로 보임.
stack_a에 2개의 node이므로

sa

stack_a를 정렬
(x) 이제 b_to_a 재귀가 동작함.
아니구나 이제, a_to_b 후반부가 동작함.
이때, stack_b로 넘어간 mid부분을 들고온다.

67 pa pa pa pa pa 
72 ra rb rb rrr rrb << rb rb rrr rb 는 사실상 헛무빙 
77 sb pa pa <<< 79번까지가 2차 재귀 회수 완료. [22, 30] 완성
80 pa rb < 1차 재귀에서 big의 정렬이 종료되고, mid를 정렬한다.
82 pa ra rb pa ra 
87 rb pa pa ra rb 
92 pa pb sa ra pa << 92번줄 최적화가 안됨. 구간이 다른 재귀함수쪽이기 때문.
97 rra rrr rrr rrr rrb 

리마인드 해보면, 1차 재귀 때 구간은
1 ~  11 s
12 ~ 21 m
22 ~ 30 b
이였음. mid를 정렬해서 a로 가져와야 하는걸로 보임.
--------------------------------------------------------------------------------
Exec pa pa [79]:
   19 < mid top [12, 21]
   12
   16
   13
   18
   14
   21
   17
   15
   20 < mid bottom
    8 < small top [1, 11]
    6
22  9
23 10
24  3
25  5
26 11
27  1
28  7
29  4
30  2 < small bottom
-- --
 a  b
--------------------------------------------------------------------------------
Exec pa pa [79]:
   19   b
   12 s
   16  m
   13 s
   18  m
   14 s
   21   b
   17  m
   15 s
   20   b
--------------------------------------------------------------------------------
가 이동을 시작해서
12 ~ 21 구간을 3분할해서
12 ~ 15 s
16 ~ 18 m
19 ~ 21 b
으로 나뉜다. 대신 b_to_a의 경우 규칙이 반대라 b stack에는 big이 아닌 small이 남게된다.
rrr과 rrb를 왜 쓰는지 알 수 있는 대목이다. 이는 고정부분 아래쪽에 있는 것을 같이 꺼내기 위함이다. 이렇게 하기 위해서는 s과 b의 갯수 차이가 최대 1개가 나야한다.
--------------------------------------------------------------------------------
Exec pa [92]:
20  8 <<<< big top [19, 21]
21  6
19  9 <<<< big bottom
22 10
23  3
24  5
25 11
26  1
27  7
28  4
29  2
30 12                   < small top
16 13 <<<< mid top
18 14
17 15 <<<< mid bottom   < small bottom
-- --
 a  b
--------------------------------------------------------------------------------
a_to_b가 
stack_a에 big을 남기고 오른쪽으러 넘기면서 mid는 stack_b 아래에 박고, small은 stack_b 위쪽에 박았다.
왜 small을 아래에 박지 않는가. 이거는 첫 재귀는 고정부가 없지만, 2번째 재귀부터는 고정부가 생기게 되므로, 고정부 밑으로 small을 넣기 위한 작업으로 보임.
(확인 필요) 이때 big을 정렬재귀를 돌리고(a_to_b를 더 진행) small과 mid는 고정부에 정렬되지 않은 채 남는다.
첫 재귀는 하나의 range가 전부 정렬될때까지(이 경우 22 ~ 30이 정렬될 때까지)
그 다음 small에 대해 정렬이 일어난다.

pb sa pa rb rb 
pa ra pa rrr rrb 

sb pa pa pa ra 
pa ra pa pa rb 
pa ra pa rb pa 
ra rb rb sa pb 
sa ra pa rra rrr 
rrr rrr rrr 

pb rb pb pb pb 
rrb 

pa pa sb pb 
pa pa pa pa ra rb 
pa rb rrr rrb 

sb pa pa
*/
    
pivot = 3 0 ~ 6
sa pb pb ss pb pb rr pa pa pa
```







## minckim님 가이드를 보면서 드는 생각

- 피봇을 잡기 전, 고정 부분을 제외한 나머지 부분의 index를 파악하고, 피봇을 결정하는게 좋아보인다.
- 2피봇 3분할이, 그나마 가장 빠른 접근법이다. 적절한 피봇을 선택하는것을 재귀로 돌리는게 그나마 나은 듯.
- 최적화를 위한 아이디어
  1. 범위 크기가 2 또는 3일 때의 최적화
     - 이건 생각보다 비효율 적인게, 범위 크기가 2 또는 3이라는 것은, 재귀의 종료조건 정도에나 명령수 3개 정도를 줄이는 역할을 할 것으로 보인다.
  2. ra, rra 호출 횟수 줄이기
     - 

- 



## 손코딩

```C
--------------------------------------------------------------------------------
Init a and b
2 
4 
3 
1 
- -
a b
--------------------------------------------------------------------------------
  
// 4개니까, 1 1 2로 나눠야함.
// hol

--------------------------------------------------------------------------------
Init a and b
 4 
 8 
 7 
 9 
 1 
10 
 6 
 3 
 2 
 5 
-- --
 a  b
  
1 ~ 10니까 피봇을 정해보자.

  ft_recursive_push_swap(&ctrl, a, 10);

ft_recursive_push_swap
{
  div = 3 = 9 / 3;
  mod = 1 = 10 % 3;
  
  parts->size = 10;
  parts->pivot_1 = 3;
  parts->pivot_2 = 8;
	parts->hold_down.size = 3;
	parts->push_up.size = 3;
	parts->push_down.size = 4;
	parts->hold_down.stack = a;
	parts->push_up.stack = b;
	parts->push_down.stack = b;
}

자 그럼 
hold_down : 7 8 9 10
push_up   : 4 5 6
push_down : 1 2 3
  
이제 넘겨보자
  
pass
----------------------------------------
    8
    5
    6
    7
 9  3
10  2
12  1
11  4
-- --
 a  b
  
9 ~ 12 를 쪼갬
ft_select_pivot
{
  div = 1 = 4 / 3;
  mod = 1 = 4 % 3;
  
  offset == 8 // 맞지
  parts->size = 4;
  parts->pivot_1 = 9;
  parts->pivot_2 = 12;
	parts->hold_down.size = 3;
	parts->push_up.size = 3;
	parts->push_down.size = 4;
	parts->hold_down.stack = a;
	parts->push_up.stack = b;
	parts->push_down.stack = b;
}

1 ~ 99 | 1 ~ 33 | 34 ~ 66 | 67 ~ 99
  div = 33
  mod = 0
  pivot_1 == 33
  pivot_2 == 67

1 ~ 100 | 1 ~ 33 | 34 ~ 66 | 67 ~ 100
  div = 33
  mod = 1
  pivot_1 == 33
  pivot_2 == 67
  
1 ~ 101 | 1 ~ 33 | 34 ~ 67 | 68 ~ 101
  div = 33
  mod = 2
  pivot_1 == 33
  pivot_2 == 68
  
1 ~ 102 | 1 ~ 34 | 35 ~ 68 | 69 ~ 102
  div == 34
  mod == 0
  
----- // 30개 테스트
 2 
 8 
28 
 5 
12 
27 
 3 
26 
19 
11 
10 
29 
22 
 9 
14 
30 
20 
24 
 4 
 1 
16 
 6 
13 
15 
21 
23 
 7 
25 
18 
17 
-- --
 a  b
  
1 ~ 30 이잖아
  div = 10
  1 ~ 10 | 11 ~ 20 | 21 ~ 30
  
----------------------------------------
   12
   19
   11
   14
   20
   16
   13
   15
   18
   17
26  7
29  6
22  1
30  4
24  9
21 10
23  3
25  5
28  8
27  2
-- --
 a  b
----------------------------------------
  
21 ~ 30 을 다시 나눔
	size = 10
  div = 3
  mod = 1
  21 ~ 23 up
  24 ~ 26 down
  27 ~ 30 hold
  
27 ~ 30
  pivot_1 = 27
  pivot_2 = 29
 
ARG=24 29 1 13 9 25 8 15 16 28 20 19 2 6 10 30 17 14 7 26 5 3 18 11 12 23 27 4 21 22



```

